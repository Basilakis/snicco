# A secure, modular and framework-agnostic PHP library to sign and verify urls.

## Table of contents

1. [Motivation](#motivation)
2. [Dependencies](#dependencies)
3. [Installation](#how-to-install)
4. [Usage](#how-to-use)
    1. [Creating a secret](#creating-a-secret)
    2. [Signing an url](#creating-a-signed-url)
    3. [Validating a signed url](#validating-a-signed-url)
        1. [psr15 middleware](#validating-a-signed-url)
        2. [other PHP applications](#validating-a-signed-url)
5. [Supported storage types](#supported-storage-types)
    1. [mysqli](#mysqli)
    2. [pdo](#pdo)
    3. [session](#session)
    4. [memory](#memory)
    5. [WordPress bundle](#wordpress-bundle)

## Motivation

While developing the [SniccoWP framework](https://github.com/sniccowp/sniccowp) we couldn't find any good
**standalone** PHP-libraries for signing urls on GitHub. We needed this functionality in a couple of places, so we
decided to roll our own implementation.

By good we mean:

- Using strong, random secrets, generated by
  a [CSPRNG](https://en.wikipedia.org/wiki/Cryptographically-secure_pseudorandom_number_generator) and secure hash
  functions.
- Validating the signature, the expiration and an enforced usage-limit on a per url basis.
- PSR-7/15 support. No hidden dependencies on PHP super globals.
- Protection against [cache-timing-attacks](https://blog.ircmaxell.com/2014/11/its-all-about-time.html), separating the
  lookup from the validation.
- Permanently invalidating a signed url after usage.
- Defensively programmed, making incorrect usage hard.
- Support for multiple backend storages.
- A properly tested and straightforward API.

## Dependencies

- PHP ^7.3
- [paragonie/constant_time_encoding](https://github.com/paragonie/constant_time_encoding)
- [webmozart/assert](https://github.com/webmozarts/assert)

## How to Install

```sh
composer require sniccowp/signed-url
```

## How to Use

### Creating a secret

```php
// require 'vendor/autoload.php';

if(!is_file('path-outside-webroot.txt')) {

    $secret = \Snicco\SignedUrl\Secret::generate();
    file_put_contents('path-outside-webroot.txt', $secret->asString());
    
} else {

    // even better: Load in from an .env file
    $secret = \Snicco\SignedUrl\Secret::fromHexEncoded(
       file_get_contents('path-outside-webroot.txt')
    );
}
```

### Creating a signed-url

```php
$secret = /* */

// This is a simple interface, provide your own if you like.
$hasher = new \Snicco\SignedUrl\Sha256Hasher($secret);

// This is a simple interface.
// check the provided storages below in the repo or simple provide your own.
$storage = new \Snicco\SignedUrl\Storage\SessionStorage($_SESSION);

$signer = new \Snicco\SignedUrl\UrlSigner($storage, $hasher);

$lifetime_in_sec = 60;

$usage_limit = 1;

// optional: as a fourth parameter,
$context = $_SERVER['REMOTE_ADDR'].$_SERVER['HTTP_USER_AGENT']

$signed_url = $signer->sign('https://example.com/unsubscribe?user_id=12' , $lifetime_in_sec, $usage_limit, $context);

$mailer = /* */

$href = $signed_url->asString();

// $href will be something like this:
// https://example.com/unsubscribe?user_id=12expires=1639783661&signature=Del1cGmLB1wVET6PJieCrQ==|1MTBBGIpEGPVuGaKDjjrHDBusMNoWB15Ng5lKBSSLQY=

$mailer->send('user12@gmail.com', "Click <a href='{{$href}}'> here <a/> to unsubscribe.")
```

### Validating a signed-url

Validation signed urls should be performed in a middleware to avoid boilerplate.
<br> The code samples below describe the **manual** way to validate urls in any PHP app.

#### psr15

If your favorite framework is psr7/psr15 compatible and supports middleware on a per-route basis, you can use our
inbuilt [psr15 middleware](https://github.com/sniccowp/sniccowp/tree/feature/extract-magic-link/packages/signed-url-middleware)
which makes usage dead simple.

#### All PHP apps

```php
// Clean expired links periodically.
try {
    // 0-100
    $percentage = 2;
   \Snicco\SignedUrl\GarbageCollector::clean($storage, $percentage);
   
} catch (RuntimeException $e) {
    // gc did not work for some reason. Log and continue.
    error_log($e->getMessage());
    
}

$validator = new \Snicco\SignedUrl\SignedUrlValidator($storage, $hasher);

$request_target = $_SERVER['PATH_INFO'].'?'.$_SERVER['QUERY_STRING'];

try {

    // optional context, has to be the same scheme used at creation.
    $context = $_SERVER['REMOTE_ADDR'].$_SERVER['HTTP_USER_AGENT']
    
    $validator->validate( $request_target, $context);
    
} catch (\Snicco\SignedUrl\Exceptions\InvalidSignature $e ) {
        
   error_log("invalid signature.");     
   echo "This link has expired. Please request a new one."
    
} catch (\Snicco\SignedUrl\Exceptions\SignedUrlExpired $e ) {

   error_log("signed url expired.");    
   echo "This link has expired. Please request a new one."
   
} catch (\Snicco\SignedUrl\Exceptions\SignedUrlUsageExceeded $e ) {

   error_log("signed url usage exceeded.");  
   echo "This link has expired. Please request a new one."
}

// Everything is valid.
// If the link can be used multiple times the usage is decremented automatically by 1.
echo "You have been unsubscribed."
```

## Supported storage types

Every signed url storage implements `Snicco\SignedUrl\Contracts\SingedUrlStorage`.<br>By default, the following storage
classes are provided:

#### mysqli:

***

Will use an already instantiated mysqli connection. <br>The mysqli instance has to be configured to throw Exceptions.

https://www.php.net/manual/de/function.mysqli-report.php

```php
$mysqli = /*   */
$table_name = 'signed_urls'
$storage = new \Snicco\SignedUrl\Storage\MysqliStorage($storage, $table_name);
```

#### pdo:

***

Will use an already instantiated pdo connection. <br> The pdo instance has to be configured to throw Exceptions.

https://www.php.net/manual/de/pdo.error-handling.php

```php
$pdo = /*   */
$table_name = 'signed_urls'
$storage = new \Snicco\SignedUrl\Storage\PDOStorage($pdo, $table_name);
```

#### Creating tables for pdo and mysqli storage:

Running migrations is out of scope for this library.

Use your favorite migration library to create the following table (tweak to your likings).

``` sql
'CREATE TABLE `signed_urls` (
`id` varchar(255) NOT NULL,
`expires` int(11) unsigned NOT NULL,
`left_usages` tinyint unsigned NOT NULL,
`protects` varchar(255) NOT NULL,
 PRIMARY KEY (`id`),
 KEY `link_expires_at_index` (`expires`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8; '
```

### session:

***

Will use an array passed by reference or an object implementing ArrayAccess.

```php
$arr = new MyArrayAccess();
$storage = new \Snicco\SignedUrl\Storage\SessionStorage($arr);

$storage = new \Snicco\SignedUrl\Storage\SessionStorage($_SESSION);
```

### memory:

***

You can use this class for during unit testing.

```php
$storage = new \Snicco\SignedUrl\Storage\InMemoryStorage()
```

### WordPress bundle:

***

If you are using this in WordPress there is
a [dedicated bundle](https://github.com/sniccowp/sniccowp/tree/feature/extract-magic-link/packages/signed-url-wp) that
provides access to a wpdb storage and an object cache storage.

